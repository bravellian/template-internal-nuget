name: Release (GitHub Packages)

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      publishSleet:
        description: "Publish packages to the Sleet static feed"
        required: false
        default: false
        type: boolean
      forceUnlockSleet:
        description: "Delete stale .feedlock object before Sleet push"
        required: false
        default: false
        type: boolean
      sleetFeedName:
        description: "Sleet source name in sleet.json"
        required: false
        default: "nuget"
        type: string
      githubPackagesOrg:
        description: "Optional GitHub Packages org/owner override (defaults to repository owner)"
        required: false
        type: string
      semVer:
        description: "Optional semver override for manual runs"
        required: false
        type: string

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write

jobs:
  pack:
    runs-on: ubuntu-latest
    outputs:
      semVer: ${{ steps.version.outputs.semVer }}
      hasSemVer: ${{ steps.version.outputs.hasSemVer }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json

      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/packages.lock.json', '**/*.csproj', 'Directory.Packages.props', 'global.json') }}
          restore-keys: |
            nuget-${{ runner.os }}-

      - name: Locate solution
        id: sln
        shell: pwsh
        run: |
          $sln = Get-ChildItem -Path . -Filter *.slnx | Select-Object -First 1
          if (-not $sln) { $sln = Get-ChildItem -Path . -Filter *.sln | Select-Object -First 1 }
          if (-not $sln) { throw "No solution file found at repo root." }
          "sln=$($sln.Name)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Determine version input
        id: version
        shell: pwsh
        run: |
          $manualVersion = "${{ github.event.inputs.semVer }}"
          $tagRef = "${{ github.ref }}"
          $tagName = "${{ github.ref_name }}"
          $version = ""

          if ($manualVersion) {
            $version = $manualVersion.Trim()
          } elseif ($tagRef.StartsWith("refs/tags/v")) {
            $version = $tagName.TrimStart("v")
          }

          if ($version) {
            "semVer=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            "hasSemVer=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          } else {
            "semVer=" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            "hasSemVer=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          }

      - name: Restore
        run: dotnet restore ${{ steps.sln.outputs.sln }}

      - name: Build
        shell: pwsh
        run: |
          if ("${{ steps.version.outputs.hasSemVer }}" -eq "true") {
            dotnet build ${{ steps.sln.outputs.sln }} -c Release --no-restore -p:ContinuousIntegrationBuild=true -p:Version=${{ steps.version.outputs.semVer }}
          } else {
            dotnet build ${{ steps.sln.outputs.sln }} -c Release --no-restore -p:ContinuousIntegrationBuild=true
          }

      - name: Test (exclude integration)
        run: dotnet test --solution ${{ steps.sln.outputs.sln }} -c Release --no-build --filter "Category!=Integration&RequiresDocker!=true"

      - name: Pack
        shell: pwsh
        run: |
          if ("${{ steps.version.outputs.hasSemVer }}" -eq "true") {
            pwsh -NoProfile -File ./scripts/pack.ps1 -Configuration Release -Version ${{ steps.version.outputs.semVer }} -SkipRestore -SkipBuild
          } else {
            pwsh -NoProfile -File ./scripts/pack.ps1 -Configuration Release -SkipRestore -SkipBuild
          }

      - name: Upload NuGet artifacts
        uses: actions/upload-artifact@v4
        with:
          name: nupkgs
          if-no-files-found: error
          path: |
            artifacts/packages/*.nupkg
            artifacts/packages/*.snupkg
            !artifacts/packages/*.symbols.nupkg

  publish_github_packages:
    needs: pack
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Download NuGet artifacts
        uses: actions/download-artifact@v4
        with:
          name: nupkgs
          path: ./artifacts/publish

      - name: Push to GitHub Packages (NuGet)
        run: |
          set -euo pipefail
          GH_PACKAGES_ORG="${{ github.event.inputs.githubPackagesOrg || github.repository_owner }}"
          GH_PACKAGES_SOURCE="https://nuget.pkg.github.com/${GH_PACKAGES_ORG}/index.json"

          find ./artifacts/publish -type f -name "*.nupkg" ! -name "*.symbols.nupkg" -print0 | while IFS= read -r -d '' pkg; do
            dotnet nuget push "$pkg" --source "$GH_PACKAGES_SOURCE" --api-key "${{ secrets.GITHUB_TOKEN }}" --skip-duplicate
          done

          find ./artifacts/publish -type f -name "*.snupkg" -print0 | while IFS= read -r -d '' snupkg; do
            dotnet nuget push "$snupkg" --source "$GH_PACKAGES_SOURCE" --api-key "${{ secrets.GITHUB_TOKEN }}" --skip-duplicate
          done

  publish_sleet:
    needs: pack
    runs-on: ubuntu-latest
    concurrency:
      group: sleet-publish-${{ github.repository }}
      cancel-in-progress: false
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) || (github.event_name == 'workflow_dispatch' && github.event.inputs.publishSleet == 'true')
    permissions:
      contents: read
    env:
      SLEET_FEED_NAME: ${{ github.event.inputs.sleetFeedName || 'nuget' }}
      # Toggle for push-to-main automation.
      SLEET_PUBLISH_ENABLED: ${{ vars.SLEET_PUBLISH_ENABLED || secrets.SLEET_PUBLISH_ENABLED }}
      SLEET_PUBLISH_ENABLED_SECRET: ${{ secrets.SLEET_PUBLISH_ENABLED }}
      # Cloudflare R2/S3-compatible required secrets:
      # - SLEET_S3_BUCKET: bucket name
      # - SLEET_S3_ENDPOINT: S3 endpoint (R2 example: https://<accountid>.r2.cloudflarestorage.com)
      # - AWS_ACCESS_KEY_ID / AWS_SECRET_ACCESS_KEY
      # Optional:
      # - SLEET_S3_PREFIX: folder prefix inside bucket (example: "nuget/")
      # - SLEET_DISABLE_PAYLOAD_SIGNING: set "true" for Cloudflare R2
      # NuGet client source URL becomes: https://<your-domain>/v3/index.json
      # Point your custom domain (CNAME/proxy) to the bucket-hosted feed content.
      SLEET_S3_ENDPOINT: ${{ secrets.SLEET_S3_ENDPOINT || 'https://89688018c76ecf8a6c9021cfa667a2ae.r2.cloudflarestorage.com' }}
      SLEET_S3_BUCKET: ${{ secrets.SLEET_S3_BUCKET || 'nuget-feed' }}
      SLEET_S3_PREFIX: ${{ secrets.SLEET_S3_PREFIX || 'feeds/main' }}
      SLEET_DISABLE_PAYLOAD_SIGNING: ${{ secrets.SLEET_DISABLE_PAYLOAD_SIGNING || 'true' }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json

      - name: Download NuGet artifacts
        uses: actions/download-artifact@v4
        with:
          name: nupkgs
          path: ./artifacts/publish

      - name: Install Sleet
        run: dotnet tool install --tool-path ./.tools sleet

      - name: Optionally clear stale Sleet feed lock
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.forceUnlockSleet == 'true' }}
        shell: pwsh
        run: |
          $serviceUrl = $env:SLEET_S3_ENDPOINT.TrimEnd("/")
          $bucketSuffix = "/$($env:SLEET_S3_BUCKET)"
          if ($serviceUrl.EndsWith($bucketSuffix, [System.StringComparison]::OrdinalIgnoreCase)) {
            $serviceUrl = $serviceUrl.Substring(0, $serviceUrl.Length - $bucketSuffix.Length)
          }

          $lockObject = "s3://$($env:SLEET_S3_BUCKET)/.feedlock"
          Write-Host "Attempting stale lock cleanup for $lockObject via $serviceUrl"
          & aws s3 rm $lockObject --endpoint-url $serviceUrl --only-show-errors
          if ($LASTEXITCODE -ne 0) {
            Write-Host "No stale lock removed (or lock not found). Continuing."
          }

      - name: Validate publish_sleet configuration
        shell: pwsh
        run: |
          $missing = @()
          foreach ($name in @("SLEET_S3_BUCKET", "SLEET_S3_ENDPOINT", "AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY")) {
            if ([string]::IsNullOrWhiteSpace((Get-Item -Path "env:$name").Value)) { $missing += $name }
          }

          if ($missing.Count -gt 0) {
            throw "publish_sleet is enabled, but required secrets are missing: $($missing -join ', ')."
          }

      - name: Publish .nupkg files to Sleet (Cloudflare R2/S3-compatible)
        shell: pwsh
        run: |
          function Set-OrAddProperty {
            param(
              [Parameter(Mandatory = $true)] $Object,
              [Parameter(Mandatory = $true)] [string] $Name,
              [Parameter(Mandatory = $true)] $Value
            )

            $prop = $Object.PSObject.Properties[$Name]
            if ($null -ne $prop) {
              $prop.Value = $Value
            } else {
              $Object | Add-Member -NotePropertyName $Name -NotePropertyValue $Value
            }
          }

          $configPath = Join-Path $env:RUNNER_TEMP "sleet.json"
          & "./.tools/sleet" createconfig --s3 --output $configPath

          $json = Get-Content -Path $configPath -Raw | ConvertFrom-Json
          $source = $json.sources[0]
          Set-OrAddProperty -Object $source -Name "name" -Value $env:SLEET_FEED_NAME
          Set-OrAddProperty -Object $source -Name "bucketName" -Value $env:SLEET_S3_BUCKET
          Set-OrAddProperty -Object $source -Name "compress" -Value $false

          # Normalize prefix and fail closed if it resolves to root.
          $rawPrefix = $env:SLEET_S3_PREFIX
          if ([string]::IsNullOrWhiteSpace($rawPrefix)) {
            $rawPrefix = "feeds/main"
          }
          $normalizedPrefix = $rawPrefix.Trim().Trim("/")
          if ([string]::IsNullOrWhiteSpace($normalizedPrefix)) {
            throw "SLEET_S3_PREFIX resolves to an empty path. Use a non-root prefix such as 'feeds/main'."
          }
          Write-Host "Using SLEET_S3_PREFIX: '$normalizedPrefix'"

          $rawEndpoint = $env:SLEET_S3_ENDPOINT.TrimEnd("/")
          $serviceUrl = $rawEndpoint
          $bucketSuffix = "/$($env:SLEET_S3_BUCKET)"
          if ($serviceUrl.EndsWith($bucketSuffix, [System.StringComparison]::OrdinalIgnoreCase)) {
            $serviceUrl = $serviceUrl.Substring(0, $serviceUrl.Length - $bucketSuffix.Length)
          }
          [Uri]$parsedServiceUrl = $null
          if (-not [Uri]::TryCreate($serviceUrl, [System.UriKind]::Absolute, [ref]$parsedServiceUrl)) {
            throw "SLEET_S3_ENDPOINT is not a valid absolute URL: '$serviceUrl'."
          }
          if ($source.PSObject.Properties["region"]) { $source.PSObject.Properties.Remove("region") }
          if ($source.PSObject.Properties["serviceUrl"]) { $source.PSObject.Properties.Remove("serviceUrl") }
          Set-OrAddProperty -Object $source -Name "serviceURL" -Value $serviceUrl
          Set-OrAddProperty -Object $source -Name "accessKeyId" -Value $env:AWS_ACCESS_KEY_ID
          Set-OrAddProperty -Object $source -Name "secretAccessKey" -Value $env:AWS_SECRET_ACCESS_KEY
          if ($source.PSObject.Properties["profileName"]) { $source.PSObject.Properties.Remove("profileName") }

          $pathBase = $rawEndpoint
          if (-not $pathBase.EndsWith($bucketSuffix, [System.StringComparison]::OrdinalIgnoreCase)) {
            $pathBase = "$pathBase/$($env:SLEET_S3_BUCKET)"
          }
          $pathBase = "$pathBase/$normalizedPrefix"
          $pathUrl = "$($pathBase.TrimEnd('/'))/"
          [Uri]$parsedPathUrl = $null
          if (-not [Uri]::TryCreate($pathUrl, [System.UriKind]::Absolute, [ref]$parsedPathUrl)) {
            throw "Sleet path URL is not valid: '$pathUrl'."
          }
          Set-OrAddProperty -Object $source -Name "path" -Value $pathUrl
          Write-Host "Resolved Sleet source path: $pathUrl"
          Set-OrAddProperty -Object $source -Name "disablePayloadSigning" -Value ($env:SLEET_DISABLE_PAYLOAD_SIGNING -eq "true")

          $json | ConvertTo-Json -Depth 10 | Set-Content -Path $configPath -Encoding utf8NoBOM

          $pushDir = Join-Path $env:RUNNER_TEMP "sleet-packages"
          New-Item -ItemType Directory -Path $pushDir -Force | Out-Null

          Get-ChildItem -Path "./artifacts/publish" -Recurse -File -Filter "*.nupkg" |
            Where-Object { -not $_.Name.EndsWith(".symbols.nupkg") } |
            ForEach-Object { Copy-Item -Path $_.FullName -Destination $pushDir -Force }

          # Intentionally not publishing .snupkg; add a separate symbols flow later if needed.
          $packageCount = (Get-ChildItem -Path $pushDir -File -Filter "*.nupkg").Count
          if ($packageCount -eq 0) { throw "No .nupkg files found to publish." }

          # Sleet's duplicate-safe mode is --skip-existing (equivalent intent to --skip-duplicate).
          # Guard against indefinite feed-lock waits by timing out with a clear unlock hint.
          $pushArgs = @("push", $pushDir, "-c", $configPath, "-s", $env:SLEET_FEED_NAME, "--skip-existing")
          $process = Start-Process -FilePath "./.tools/sleet" -ArgumentList $pushArgs -NoNewWindow -PassThru
          if (-not $process.WaitForExit(600000)) {
            try { $process.Kill($true) } catch { }
            throw "Sleet push timed out after 10 minutes, likely waiting on a stale feed lock. If no other publish is active, delete '.feedlock' in bucket '$($env:SLEET_S3_BUCKET)' and rerun."
          }

          if ($process.ExitCode -ne 0) {
            throw "Sleet push failed with exit code $($process.ExitCode)."
          }

